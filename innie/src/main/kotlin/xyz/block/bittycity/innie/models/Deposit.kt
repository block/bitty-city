package xyz.block.bittycity.innie.models

import app.cash.kfsm.Value
import arrow.core.raise.result
import org.bitcoinj.base.Address
import org.joda.money.Money
import xyz.block.bittycity.common.models.BitcoinDisplayUnits
import xyz.block.bittycity.common.models.Bitcoins
import xyz.block.bittycity.common.models.CustomerId
import xyz.block.bittycity.common.models.LedgerTransactionId
import xyz.block.bittycity.common.utils.CurrencyConversionUtils.bitcoinsToUsd
import xyz.block.domainapi.ProcessingState
import java.time.Instant

data class Deposit(
  /** The deposit's unique token. */
  override val id: DepositToken,

  /** The state of this deposit, in terms of the innie state machine. */
  override val state: DepositState,

  /** The time in epoch millis that this deposit was created. */
  val createdAt: Instant? = null,

  /** The time in epoch millis that this deposit was updated. */
  val updatedAt: Instant? = null,

  /** Each time the deposit's state is updated, the version increments. Zero-based. */
  val version: Long? = null,

  /** The ID of the customer receiving the deposit. */
  val customerId: CustomerId,

  /** The deposit amount, in bitcoins. */
  val amount: Bitcoins,

  /** The exchange rate used when creating the deposit. */
  val exchangeRate: Money,

  /** The wallet address into which the deposit is sent. */
  val targetWalletAddress: Address,

  /** The blockchain transaction id hash for this deposit. */
  val blockchainTransactionId: String,

  /** The index of the output in the transaction. */
  val blockchainTransactionOutputIndex: Int,

  /** The identifier of this deposit in the system that detects deposits in the blockchain. */
  val paymentToken: String,

  /** The ledger transaction id generated by the ledgering system. */
  val ledgerTransactionId: LedgerTransactionId? = null,

  /** The reason attributed to the failure of this deposit, if applicable. */
  val failureReason: DepositFailureReason? = null,

  /** If the deposit cannot be accepted then it has to be reversed. There can be multiple reversal attempts. */
  val reversals: List<DepositReversal> = emptyList(),
) : Value<DepositToken, Deposit, DepositState> {
  override fun update(newState: DepositState): Deposit = this.copy(state = newState)

  val currentReversal: DepositReversal? get() = reversals.lastOrNull()

  fun updateCurrentReversal(transform: (DepositReversal) -> DepositReversal): Result<Deposit> = result {
    val currentReversal = currentReversal
      ?: raise(IllegalArgumentException("Tried to update current reversal but there are no reversals"))
    copy(reversals = reversals.dropLast(1) + transform(currentReversal))
  }

  val fiatEquivalentAmount: Money = bitcoinsToUsd(amount, exchangeRate)

  fun asProcessingState(
    bitcoinDisplayUnits: BitcoinDisplayUnits? = null,
  ): ProcessingState<Deposit, RequirementId> = state.processingState(this, bitcoinDisplayUnits)
}
