package xyz.block.bittycity.outie.models

import app.cash.kfsm.Value
import org.bitcoinj.base.Address
import org.joda.money.CurrencyUnit
import org.joda.money.Money
import xyz.block.bittycity.outie.models.Bitcoins.Companion.BITCOINS_PER_BTC
import xyz.block.domainapi.ProcessingState
import java.math.RoundingMode
import java.time.Instant

data class Withdrawal(
  /** The withdrawal's unique token. */
  override val id: WithdrawalToken,

  /** The time in epoch millis that this withdrawal was created. */
  val createdAt: Instant,

  /** The time in epoch millis that this withdrawal was updated. */
  val updatedAt: Instant,

  /** Each time the withdrawal's state is updated, the version increments. Zero-based. */
  val version: Long,

  /** The initiating customer's ID. */
  val customerId: CustomerId,

  /** The state of this withdrawal, in terms of the bitty-lib state machine */
  override val state: WithdrawalState,

  /** The wallet address into which the funds will be sent */
  val targetWalletAddress: Address? = null,

  /** If the user has gone back, this holds the previous target wallet address that was entered. */
  val previousTargetWalletAddress: Address? = null,

  /** The source stored balance token from where the funds are withdrawn */
  val sourceBalanceToken: BalanceId,

  /** The withdrawal amount, in bitcoins. */
  val amount: Bitcoins? = null,

  /** If the user has gone back, this holds the previous amount that was entered. */
  val previousAmount: Bitcoins? = null,

  /** An optional note that the customer can add to the withdrawal.*/
  val note: String? = null,

  /** If the user has gone back, this holds the previous note that was entered. */
  val previousNote: String? = null,

  /** The speed (selected by the customer) at which this withdrawal will be confirmed on blockchain */
  val selectedSpeed: WithdrawalSpeedOption? = null,

  /** If the user has gone back, this holds the previous speed that was selected. */
  val previousSelectedSpeed: WithdrawalSpeedOption? = null,

  /** The ledger transaction id generated by the ledgering system */
  val ledgerTransactionId: LedgerTransactionId? = null,

  /** The reason attributed to the failure of this withdrawal if applicable */
  val failureReason: FailureReason? = null,

  /** The origin of this withdrawal */
  val source: String = DEFAULT_SOURCE,

  /** The "provider" of a withdrawal address */
  val provider: String? = null,

  /** The blockchain transaction id hash (if any) for this withdrawal */
  val blockchainTransactionId: String? = null,

  /**
   * Records the user decision if a scam warning was presented to them.
   */
  val userHasAcceptedRisk: Boolean? = null,

  /**
   * Records the user authenticating again to approve the withdrawal.
   */
  val stepUpAuthenticated: Boolean? = null,

  /**
   * Records the user's confirmation of the details of the withdrawal.
   */
  val userHasConfirmed: Boolean? = null,

  /**
   * The exchange rate used when creating the withdrawal. This rate is used to display the
   * withdrawal amount in the user's fiat currency and to calculate the flat rate service fee, which
   * is specified in fiat and then converted to sats.
   */
  val exchangeRate: Money? = null,

  /**
   * If a withdrawal is flagged and held for sanctions the user must enter the reason for the
   * withdrawal to assist compliance agents in deciding the final outcome.
   */
  val reasonForWithdrawal: String? = null,

  /**
   * If a withdrawal is held for manual sanctions review then no fee is charged, because the SLAs
   * that correspond to the selected speed, if not the free tier, cannot be met. In this case we
   * keep the original speed selection but indicate that the fee was refunded using this flag.
   */
  val feeRefunded: Boolean = false,

  /**
   * If a withdrawal is subject to the Travel Rule where the customer withdraws more than $3000 USD
   * to their noncustodial wallet, then the customer must complete self-attestation by providing
   * additional information about the recipient
   */
  val selfAttestationDestination: String? = null,

  /**
   * The index of the output in the transaction.
   */
  val blockchainTransactionOutputIndex: Int? = null,

  /**
   * Increments every time the user goes back. Allows generating a different hash when the user
   * goes backs but submits the same payload.
   */
  val backCounter: Int = 0
) : Value<WithdrawalToken, Withdrawal, WithdrawalState> {
  override fun update(newState: WithdrawalState): Withdrawal = this.copy(state = newState)

  val fiatEquivalentAmount: Money? = this.amount?.let { amount ->
    exchangeRate?.let { satoshiToUsd(amount, exchangeRate) }
  }

  fun asProcessingState(
    bitcoinDisplayUnits: BitcoinDisplayUnits? = null,
  ): ProcessingState<Withdrawal, RequirementId> = state.processingState(this, bitcoinDisplayUnits)

  companion object {
    const val DEFAULT_SOURCE = "BITTY"

    fun satoshiToUsd(amount: Bitcoins, exchangeRate: Money): Money = Money.ofMinor(
      CurrencyUnit.USD,
      amount.units.toBigDecimal()
        .multiply(exchangeRate.amountMinor)
        .divide(BITCOINS_PER_BTC.toBigDecimal(), 0, RoundingMode.HALF_DOWN)
        .toLong()
    )

    fun usdToSatoshi(usdAmount: Money, exchangeRate: Money): Bitcoins {
      val satoshiValue = usdAmount.amountMinor
        .multiply(BITCOINS_PER_BTC.toBigDecimal())
        .divide(exchangeRate.amountMinor, 0, RoundingMode.HALF_DOWN)
        .toLong()

      return Bitcoins(satoshiValue)
    }
  }
}
